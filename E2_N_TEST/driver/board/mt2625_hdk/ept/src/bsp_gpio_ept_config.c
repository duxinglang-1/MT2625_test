/* Copyright Statement:
 *
 * (C) 2005-2016  MediaTek Inc. All rights reserved.
 *
 * This software/firmware and related documentation ("MediaTek Software") are
 * protected under relevant copyright laws. The information contained herein
 * is confidential and proprietary to MediaTek Inc. ("MediaTek") and/or its licensors.
 * Without the prior written permission of MediaTek and/or its licensors,
 * any reproduction, modification, use or disclosure of MediaTek Software,
 * and information contained herein, in whole or in part, shall be strictly prohibited.
 * You may only use, reproduce, modify, or distribute (as applicable) MediaTek Software
 * if you have agreed to and been bound by the applicable license agreement with
 * MediaTek ("License Agreement") and been granted explicit permission to do so within
 * the License Agreement ("Permitted User").  If you are not a Permitted User,
 * please cease any access or use of MediaTek Software immediately.
 * BY OPENING THIS FILE, RECEIVER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
 * THAT MEDIATEK SOFTWARE RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES
 * ARE PROVIDED TO RECEIVER ON AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL
 * WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
 * NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
 * SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
 * SUPPLIED WITH MEDIATEK SOFTWARE, AND RECEIVER AGREES TO LOOK ONLY TO SUCH
 * THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. RECEIVER EXPRESSLY ACKNOWLEDGES
 * THAT IT IS RECEIVER'S SOLE RESPONSIBILITY TO OBTAIN FROM ANY THIRD PARTY ALL PROPER LICENSES
 * CONTAINED IN MEDIATEK SOFTWARE. MEDIATEK SHALL ALSO NOT BE RESPONSIBLE FOR ANY MEDIATEK
 * SOFTWARE RELEASES MADE TO RECEIVER'S SPECIFICATION OR TO CONFORM TO A PARTICULAR
 * STANDARD OR OPEN FORUM. RECEIVER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND
 * CUMULATIVE LIABILITY WITH RESPECT TO MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
 * AT MEDIATEK'S OPTION, TO REVISE OR REPLACE MEDIATEK SOFTWARE AT ISSUE,
 * OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY RECEIVER TO
 * MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
 */


#include "mt2625.h"
#include "ept_gpio_drv.h"
#include "hal_log.h"
#include "bsp_gpio_ept_config.h"

/* joint together the MACROs generated by EPT to 32-bits data as a result of the GPIO register is 32-bit,
   the data will be written to corresponding register after jointed.
*/
#define GPIO_HWORD_REG_VAL(name, port0, port1, port2, port3, port4, port5, port6, port7, port8, port9, port10, \
                                port11, port12, port13, port14, port15, port16, port17, port18, port19, port20, port21, \
                               port22, port23, port24, port25, port26, port27, port28, port29, port30, port31)      \
((GPIO_PORT##port0##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*0) & 0x1f)) | \
(GPIO_PORT##port1##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*1) & 0x1f)) | \
(GPIO_PORT##port2##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*2) & 0x1f)) | \
(GPIO_PORT##port3##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*3) & 0x1f)) | \
(GPIO_PORT##port4##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*4) & 0x1f)) | \
(GPIO_PORT##port5##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*5) & 0x1f)) | \
(GPIO_PORT##port6##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*6) & 0x1f)) | \
(GPIO_PORT##port7##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*7) & 0x1f)) | \
(GPIO_PORT##port8##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*8) & 0x1f)) | \
(GPIO_PORT##port9##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*9) & 0x1f)) | \
(GPIO_PORT##port10##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*10) & 0x1f)) |\
(GPIO_PORT##port11##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*11) & 0x1f)) |  \
(GPIO_PORT##port12##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*12) & 0x1f)) | \
(GPIO_PORT##port13##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*13) & 0x1f)) | \
(GPIO_PORT##port14##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*14) & 0x1f)) | \
(GPIO_PORT##port15##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*15) & 0x1f)) | \
(GPIO_PORT##port16##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*16) & 0x1f)) | \
(GPIO_PORT##port17##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*17) & 0x1f)) |  \
(GPIO_PORT##port18##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*18) & 0x1f)) |  \
(GPIO_PORT##port19##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*19) & 0x1f)) |  \
(GPIO_PORT##port20##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*20) & 0x1f)) | \
(GPIO_PORT##port21##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*21) & 0x1f)) | \
(GPIO_PORT##port22##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*22) & 0x1f)) | \
(GPIO_PORT##port23##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*23) & 0x1f)) | \
(GPIO_PORT##port24##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*24) & 0x1f)) | \
(GPIO_PORT##port25##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*25) & 0x1f)) |  \
(GPIO_PORT##port26##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*26) & 0x1f)) |  \
(GPIO_PORT##port27##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*27) & 0x1f)) |  \
(GPIO_PORT##port28##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*28) & 0x1f)) | \
(GPIO_PORT##port29##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*29) & 0x1f)) | \
(GPIO_PORT##port30##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*30) & 0x1f)) | \
(GPIO_PORT##port31##_##name<<((GPIO_##name##_##ONE_CONTROL_BITS*31) & 0x1f)))



GPIO_BASE_REGISTER_T *ept_gpio_base = (GPIO_BASE_REGISTER_T *)(GPIO_BASE);
GPIO_CFG0_REGISTER_T *ept_gpio_cfg0 = (GPIO_CFG0_REGISTER_T *)(IO_CFG_0_BASE);
GPIO_CFG1_REGISTER_T *ept_gpio_cfg1 = (GPIO_CFG1_REGISTER_T *)(IO_CFG_1_BASE);

#define GPIO_MODE_MASK_BIT     0xF

const uint32_t GPIO_REG_PIN_MASK[8] = {EPT_GPIO_PIN_MASK_0,EPT_GPIO_PIN_MASK_1,0,0,0,0,0,0};

//#define EPT_DEBUG_LOG


/**
  * @brief  write the joint data about GPIO mode to GPIO mode register one by one
  * @param  None
  * @retval None
  */
void gpio_mode_init(void)
{
    uint32_t i, j;
    uint32_t reg_mask[GPIO_MODE_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_MODE_REG_MAX_NUM
    uint32_t mode_temp[GPIO_MODE_REG_MAX_NUM] = { GPIO_MODE_ALL_VALUE };

    for (i = 0; i<GPIO_MODE_REG_MAX_NUM; i++) { 
        
        reg_mask[i] = 0; 
        
        for (j = 0; j < GPIO_MODE_ONE_REG_CONTROL_NUM; j++) {
            
           temp = j + i*GPIO_MODE_ONE_REG_CONTROL_NUM; /*GPIO number*/

           /*check the mask bit is available*/
           if ((1<<(temp%32)) &  GPIO_REG_PIN_MASK[temp/32]) {
                reg_mask[i] |=  0xf <<(GPIO_MODE_ONE_CONTROL_BITS*j);
           }
        }
    }
        
    for (i = 0; i < GPIO_MODE_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_MODE.CLR[i] = reg_mask[i];
        ept_gpio_base->GPIO_MODE.SET[i] = mode_temp[i];

        #ifdef EPT_DEBUG_LOG
        printf("GPIO_MODE[%d]: =0x%.8x, reg_mask[%d]=0x%.8x\r\n",i, mode_temp[i],i,reg_mask[i]);
        #endif

    }

    //GPIO30
    if (((mode_temp[3]>>24)&0xf) == 5) {
        /* set analog pin*/
       ept_gpio_cfg1->GPIO_G.CLR = 1;
    }
    else {
        /* set digital pin*/
       ept_gpio_cfg1->GPIO_G.SET = 1;
    }

    //GPIO31
    if (((mode_temp[3]>>28)&0xf) == 5) {
        /* set analog pin*/
       ept_gpio_cfg1->GPIO_G.CLR = (1<<1);
    }
    else {
        /* set digital pin*/
       ept_gpio_cfg1->GPIO_G.SET = (1<<1);
    }

    //GPIO32
    if (((mode_temp[4]>>0)&0xf) == 5) {
        /* set analog pin*/
       ept_gpio_cfg1->GPIO_G.CLR = (1<<2);
    }
    else {
        /* set digital pin*/
       ept_gpio_cfg1->GPIO_G.SET = (1<<2);
    }

    //GPIO33
    if (((mode_temp[4]>>4)&0xf) == 5) {
        /* set analog pin*/
       ept_gpio_cfg1->GPIO_G.CLR = (1<<3);
    }
    else {
        /* set digital pin*/
       ept_gpio_cfg1->GPIO_G.SET = (1<<3);
    }

    //GPIO34
    if (((mode_temp[4]>>8)&0xf) == 5) {
        /* set analog pin*/
       ept_gpio_cfg1->GPIO_G.CLR = (1<<4);
    }
    else {
        /* set digital pin*/
       ept_gpio_cfg1->GPIO_G.SET = (1<<4);
    }
#endif
}



/**
  * @brief  write the joint data about GPIO direction configuration to GPIO direction register one by one
  * @param  None
  * @retval None
  */
void gpio_dir_init(void)
{
    uint32_t i,j;
    uint32_t reg_mask[GPIO_DIR_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_DIR_REG_MAX_NUM
    uint32_t dir_temp[GPIO_DIR_REG_MAX_NUM] = { GPIO_DIR_ALL_VALUE };

    for (i = 0; i<GPIO_DIR_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;
        
        for (j = 0; j < GPIO_DIR_ONE_REG_CONTROL_NUM; j++) {
           temp = j;

           if ((1<<temp) &  GPIO_REG_PIN_MASK[i])
           reg_mask[i] |= 1<<(GPIO_DIR_ONE_CONTROL_BITS*j);
        }
    }
    
    for (i = 0; i < GPIO_DIR_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_DIR.CLR[i] = reg_mask[i];
        ept_gpio_base->GPIO_DIR.SET[i] = dir_temp[i];
    }
#endif
}



/**
  * @brief  write the joint data about GPIO pull configuration about pullsel to GPIO pullsel register one by one
  * @param  None
  * @retval None
  */
void gpio_pu_init(void)
{
    uint32_t i;
    uint32_t reg_mask[GPIO_PU_REG_MAX_NUM];

#ifdef GPIO_PU_REG_MAX_NUM
    uint32_t pullsel_temp[GPIO_PU_REG_MAX_NUM] = { GPIO_PU_ALL_VALUE };

    for (i=0;i<GPIO_PU_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }
   
    /*GPIO2 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<2)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO5 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<5)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO24~29 bit2~7*/
    for(i=0; i<6; i++) {
        if ((1<<(24+i))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i+2);
        }
    }

    /*GPIO30 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<30)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO31 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<31)) {
        reg_mask[1] |= 1<<1;
    }

    /*GPIO32~34 bit2~4*/
    for (i=0; i<3; i++) {
        if ((1<<(i+2))&GPIO_REG_PIN_MASK[1]) {
            reg_mask[1] |= 1<<(i+2);
        }   
    }
    
    ept_gpio_cfg0->GPIO_PU.CLR = reg_mask[0];
    ept_gpio_cfg0->GPIO_PU.SET = pullsel_temp[0];

    ept_gpio_cfg1->GPIO_PU.CLR = reg_mask[1];
    ept_gpio_cfg1->GPIO_PU.SET = pullsel_temp[1];

    #ifdef EPT_DEBUG_LOG
    printf("cfg0_PU: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PU: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PU: pullsel_temp[0]=0x%.8x\r\n", pullsel_temp[0]);
    printf("cfg1_PU: pullsel_temp[1]=0x%.8x\r\n", pullsel_temp[1]);
    #endif
#endif
}



/**
  * @brief  write the joint data about GPIO pull configuration about pullen to GPIO pullen register one by one
  * @param  None
  * @retval None
  */
void gpio_pd_init(void)
{
    uint32_t i;
    uint32_t reg_mask[GPIO_PD_REG_MAX_NUM];

#ifdef GPIO_PD_REG_MAX_NUM
    uint32_t pullsel_temp[GPIO_PD_REG_MAX_NUM] = { GPIO_PD_ALL_VALUE };

    for (i=0;i<GPIO_PD_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }
   
    /*GPIO2 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<2)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO5 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<5)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO24~29 bit2~7*/
    for(i=0; i<6; i++) {
        if ((1<<(24+i))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i+2);
        }
    }

    /*GPIO30 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<30)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO31 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<31)) {
        reg_mask[1] |= 1<<1;
    }

    /*GPIO32~34 bit2~4*/
    for (i=0; i<3; i++) {
        if ((1<<(i+2))&GPIO_REG_PIN_MASK[1]) {
            reg_mask[1] |= 1<<(i+2);
        }   
    }
    
    ept_gpio_cfg0->GPIO_PD.CLR = reg_mask[0];
    ept_gpio_cfg0->GPIO_PD.SET = pullsel_temp[0];

    ept_gpio_cfg1->GPIO_PD.CLR = reg_mask[1];
    ept_gpio_cfg1->GPIO_PD.SET = pullsel_temp[1];

    #ifdef EPT_DEBUG_LOG
    printf("cfg0_PD: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PD: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PD: pullsel_temp[0]=0x%.8x\r\n", pullsel_temp[0]);
    printf("cfg1_PD: pullsel_temp[1]=0x%.8x\r\n", pullsel_temp[1]);
    #endif
#endif
}



/**
  * @brief  write the joint data about GPIO output data to GPIO output data register one by one
  * @param  None
  * @retval None
  */
void gpio_output_init(void)
{
    uint32_t i,j;
    uint32_t reg_mask[GPIO_OUTPUT_LEVEL_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_OUTPUT_LEVEL_REG_MAX_NUM
    uint32_t out_temp[GPIO_OUTPUT_LEVEL_REG_MAX_NUM] = { GPIO_OUTPUT_LEVEL_ALL_VALUE };

    for (i = 0; i<GPIO_OUTPUT_LEVEL_REG_MAX_NUM; i++) {
        reg_mask[i] = 0;
        
        for (j = 0; j < GPIO_OUTPUT_LEVEL_ONE_REG_CONTROL_NUM; j++) {
           temp = j;

           if ((1<<temp) &  GPIO_REG_PIN_MASK[i])
           reg_mask[i] |= 1<<(GPIO_OUTPUT_LEVEL_ONE_CONTROL_BITS*j);
        }
    }
    
    for (i = 0; i < GPIO_OUTPUT_LEVEL_REG_MAX_NUM; i++) {
        ept_gpio_base->GPIO_DOUT.CLR[i] = reg_mask[i];
        ept_gpio_base->GPIO_DOUT.SET[i] = out_temp[i];
    }
#endif
}


/**
  * @brief  write the joint data about GPIO pull configuration about PUPD to GPIO pupd register one by one
  * @param  None
  * @retval None
  */
void gpio_pupd_init(void)
{
    uint32_t i;
    uint32_t reg_mask[GPIO_PUPD_REG_MAX_NUM];

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t pupd_temp[GPIO_PUPD_REG_MAX_NUM] = { GPIO_PUPD_ALL_VALUE };

    for (i=0;i<GPIO_PUPD_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO0 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<0)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO1 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<1)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO3 bit2*/
    if (GPIO_REG_PIN_MASK[0] & (1<<3)) {
        reg_mask[0] |= 1<<2;
    }

    /*GPIO4 bit3*/
    if (GPIO_REG_PIN_MASK[0] & (1<<4)) {
        reg_mask[0] |= 1<<3;
    }
    
    /*GPIO6~23 bit4~21*/
    for(i=4; i<22;i++) {
        if ((1<<(i+2))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<i;
        }
    }

    /*GPIO35 bit0*/
    if (GPIO_REG_PIN_MASK[1] & (1<<3)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO36 bit1*/
    if (GPIO_REG_PIN_MASK[1] & (1<<4)) {
        reg_mask[1] |= 1<<1;
    }

    ept_gpio_cfg0->GPIO_PUPD.CLR = reg_mask[0];
    ept_gpio_cfg0->GPIO_PUPD.SET = pupd_temp[0];

    ept_gpio_cfg1->GPIO_PUPD.CLR = reg_mask[1];
    ept_gpio_cfg1->GPIO_PUPD.SET = pupd_temp[1];

    #ifdef EPT_DEBUG_LOG
    printf("cfg0_PUPD: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PUPD: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PUPD: pullsel_temp[0]=0x%.8x\r\n", pupd_temp[0]);
    printf("cfg1_PUPD: pullsel_temp[1]=0x%.8x\r\n", pupd_temp[1]);
    #endif
#endif
}


/**
  * @brief  write the joint data about GPIO pull configuration about R0 to GPIO R0 register one by one
  * @param  None
  * @retval None
  */
void gpio_r0_r1_init(void)
{
    uint32_t i;
    uint32_t reg_mask[GPIO_R0R1_REG_MAX_NUM];

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t r0_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R0_ALL_VALUE };
    uint32_t r1_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R1_ALL_VALUE };

    for (i=0;i<GPIO_R0R1_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO0 bit0*/
    if (GPIO_REG_PIN_MASK[0] & (1<<0)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO1 bit1*/
    if (GPIO_REG_PIN_MASK[0] & (1<<1)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO3 bit2*/
    if (GPIO_REG_PIN_MASK[0] & (1<<3)) {
        reg_mask[0] |= 1<<2;
    }

    /*GPIO4 bit3*/
    if (GPIO_REG_PIN_MASK[0] & (1<<4)) {
        reg_mask[0] |= 1<<3;
    }
    
    /*GPIO6~23 bit4~21*/
    for(i=4; i<22;i++) {
        if ((1<<(i+2))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i);
        }
    }

    /*GPIO35 bit0*/
    if (GPIO_REG_PIN_MASK[1] & (1<<3)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO36 bit1*/
    if (GPIO_REG_PIN_MASK[1] & (1<<4)) {
        reg_mask[1] |= 1<<1;
    }

    ept_gpio_cfg0->GPIO_R0.CLR = reg_mask[0];
    ept_gpio_cfg0->GPIO_R1.CLR = reg_mask[0];
    ept_gpio_cfg0->GPIO_R0.SET = r0_temp[0];
    ept_gpio_cfg0->GPIO_R1.SET = r1_temp[0];

    ept_gpio_cfg1->GPIO_R0.CLR = reg_mask[1];
    ept_gpio_cfg1->GPIO_R1.CLR = reg_mask[1];
    ept_gpio_cfg1->GPIO_R0.SET = r0_temp[1];
    ept_gpio_cfg1->GPIO_R1.SET = r1_temp[1];

    #ifdef EPT_DEBUG_LOG
    printf("cfg0_R0: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg0_R0: r0_temp[0]=0x%.8x\r\n", r0_temp[0]);
    printf("cfg0_R1: r1_temp[0]=0x%.8x\r\n", r1_temp[0]);

    printf("cfg1_R0: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg1_R0: r0_temp[1]=0x%.8x\r\n", r0_temp[1]);
    printf("cfg1_R1: r1_temp[1]=0x%.8x\r\n", r1_temp[1]);
    #endif
#endif
}

#define KEYPAD_DRV_CTRL   TOP_MISC_CFG_BASE+0x00f0

void gpio_keypad_default_init(void)
{
    (*(volatile uint32_t*)(KEYPAD_DRV_CTRL))   = 0x02000000;  // KCOL pull up
}


void gpio_tesel_init(void)
{
    uint32_t temp;

    ept_gpio_cfg0->GPIO_TDSEL.RW[0] = GPIO_VOLTAGE_TYPE_0;  /*GPIO0~GPIO7*/
    ept_gpio_cfg0->GPIO_TDSEL.RW[1] = GPIO_VOLTAGE_TYPE_1;  /*GPIO8~GPIO15*/
    ept_gpio_cfg0->GPIO_TDSEL.RW[2] = GPIO_VOLTAGE_TYPE_2;  /*GPIO16~GPIO23*/


    temp = ept_gpio_cfg0->GPIO_TDSEL.RW[3];                 /*GPIO24~GPIO29*/
    temp &= 0xff000000;
    temp |= (GPIO_VOLTAGE_TYPE_3 & 0x00ffffff);
    ept_gpio_cfg0->GPIO_TDSEL.RW[3] = temp;



    temp = ept_gpio_cfg1->GPIO_TDSEL.RW[0];                 /*GPIO30~GPIO36*/
    temp &= 0xf0000000;
    temp |= (((GPIO_VOLTAGE_TYPE_3>>24) & 0xff) + ((GPIO_VOLTAGE_TYPE_4<<8)&0x0fffff00));
    ept_gpio_cfg1->GPIO_TDSEL.RW[0] = temp;

	printf("addr =0x%.8x;  temp=0x%.8x\r\n",&ept_gpio_cfg1->GPIO_TDSEL.RW[0],temp);
}

/**
  * @brief  Main program to make the configuration of EPT to take effect
  * @param  None
  * @retval None
  */
void bsp_ept_gpio_setting_init(void)
{
    #ifdef EPT_DEBUG_LOG
    printf("call bsp_ept_gpio_setting_init\r\n");
    #endif
    
    gpio_mode_init();
    gpio_dir_init();
    gpio_pu_init();
    gpio_pd_init();
    gpio_pupd_init();
    gpio_r0_r1_init();
    gpio_output_init();
    gpio_keypad_default_init();
    gpio_tesel_init();
    
}

void gpio_pin_mode_default(uint8_t pin)
{
    uint32_t i, j, temp;
    uint32_t reg_mask[GPIO_MODE_REG_MAX_NUM];

#ifdef GPIO_MODE_REG_MAX_NUM
    uint32_t mode_temp[GPIO_MODE_REG_MAX_NUM] = { GPIO_MODE_ALL_VALUE };

    i = pin / GPIO_MODE_ONE_REG_CONTROL_NUM;
    j = pin % GPIO_MODE_ONE_REG_CONTROL_NUM;
    reg_mask[i] = 0;
    if ((1<<(pin%32)) & GPIO_REG_PIN_MASK[pin/32]) {
        reg_mask[i] |= (0xf<<(GPIO_MODE_ONE_CONTROL_BITS*j));
    }

    ept_gpio_base->GPIO_MODE.CLR[i] = reg_mask[i];
    temp = ept_gpio_base->GPIO_MODE.SET[i]&(~reg_mask[i]);
    temp |= (mode_temp[i]&reg_mask[i]);
    ept_gpio_base->GPIO_MODE.SET[i] = temp;

#ifdef EPT_DEBUG_LOG
    printf("GPIO_MODE[%d]: =0x%.8x, reg_mask[%d]=0x%.8x\r\n",i, temp,i,reg_mask[i]);
 #endif
#endif
}

void gpio_pin_dir_default(uint8_t pin)
{
    uint32_t i,j, temp;
    uint32_t reg_mask[GPIO_DIR_REG_MAX_NUM];

#ifdef GPIO_DIR_REG_MAX_NUM
    uint32_t dir_temp[GPIO_DIR_REG_MAX_NUM] = { GPIO_DIR_ALL_VALUE };

    i = pin / GPIO_DIR_ONE_REG_CONTROL_NUM;
    j = pin % GPIO_DIR_ONE_REG_CONTROL_NUM;
    reg_mask[i] = 0;
    if ((1<<(pin%32) & GPIO_REG_PIN_MASK[pin/32])) {
        reg_mask[i] |= 1<<(GPIO_DIR_ONE_CONTROL_BITS*j);
    }

    ept_gpio_base->GPIO_DIR.CLR[i] = reg_mask[i];
    temp = ept_gpio_base->GPIO_DIR.SET[i]&(~reg_mask[i]);
    temp |= (dir_temp[i]&reg_mask[i]);
    ept_gpio_base->GPIO_DIR.SET[i] = temp;

#ifdef EPT_DEBUG_LOG
    printf("GPIO_DIR[%d]: =0x%.8x, reg_mask[%d]=0x%.8x\r\n",i, temp,i,reg_mask[i]);
#endif
#endif
}

void gpio_pin_pu_default(uint8_t pin)
{
    uint32_t i, j, temp;
    uint32_t reg_mask[GPIO_PU_REG_MAX_NUM];

#ifdef GPIO_PU_REG_MAX_NUM
    uint32_t pullsel_temp[GPIO_PU_REG_MAX_NUM] = { GPIO_PU_ALL_VALUE };

    for (i=0;i<GPIO_PU_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO2 bit0*/
    if (pin == 2 && GPIO_REG_PIN_MASK[0] & (1<<2)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO5 bit1*/
    if (pin == 5 && GPIO_REG_PIN_MASK[0] & (1<<5)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO24~29 bit2~7*/
    for(i=0; i<6; i++) {
        if (pin == (24+i) && (1<<(24+i))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i+2);
        }
    }

    /*GPIO30 bit0*/
    if (pin == 30 && GPIO_REG_PIN_MASK[0] & (1<<30)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO31 bit1*/
    if (pin == 31 && GPIO_REG_PIN_MASK[0] & (1<<31)) {
        reg_mask[1] |= 1<<1;
    }

    /*GPIO32~34 bit2~4*/
    for (i=0; i<3; i++) {
        if (pin == (32+i) && (1<<(i+2))&GPIO_REG_PIN_MASK[1]) {
            reg_mask[1] |= 1<<(i+2);
        }
    }

    if (reg_mask[0]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg0_PU=0x%.8x\r\n", ept_gpio_cfg0->GPIO_PU.SET);
#endif
        temp = (ept_gpio_cfg0->GPIO_PU.SET&(~reg_mask[0]));
        temp |= (pullsel_temp[0]&reg_mask[0]);
        pullsel_temp[0] = temp;
        ept_gpio_cfg0->GPIO_PU.CLR = reg_mask[0];
        ept_gpio_cfg0->GPIO_PU.SET = pullsel_temp[0];
    }

    if (reg_mask[1]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg1_PU=0x%.8x\r\n", ept_gpio_cfg1->GPIO_PU.SET);
#endif
        temp = (ept_gpio_cfg1->GPIO_PU.SET&(~reg_mask[1]));
        temp |= (pullsel_temp[1]&reg_mask[1]);
        pullsel_temp[1] = temp;
        ept_gpio_cfg1->GPIO_PU.CLR = reg_mask[1];
        ept_gpio_cfg1->GPIO_PU.SET = pullsel_temp[1];
    }

#ifdef EPT_DEBUG_LOG
    printf("cfg0_PU: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PU: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PU: pullsel_temp[0]=0x%.8x\r\n", pullsel_temp[0]);
    printf("cfg1_PU: pullsel_temp[1]=0x%.8x\r\n", pullsel_temp[1]);
#endif
#endif
}

void gpio_pin_pd_default(uint8_t pin)
{
    uint32_t i, temp;
    uint32_t reg_mask[GPIO_PD_REG_MAX_NUM];

#ifdef GPIO_PD_REG_MAX_NUM
    uint32_t pullsel_temp[GPIO_PD_REG_MAX_NUM] = { GPIO_PD_ALL_VALUE };

    for (i=0;i<GPIO_PD_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO2 bit0*/
    if (pin == 2 && GPIO_REG_PIN_MASK[0] & (1<<2)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO5 bit1*/
    if (pin == 5 && GPIO_REG_PIN_MASK[0] & (1<<5)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO24~29 bit2~7*/
    for(i=0; i<6; i++) {
        if (pin == (24+i) && (1<<(24+i))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i+2);
        }
    }

    /*GPIO30 bit0*/
    if (pin == 30 && GPIO_REG_PIN_MASK[0] & (1<<30)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO31 bit1*/
    if (pin == 31 && GPIO_REG_PIN_MASK[0] & (1<<31)) {
        reg_mask[1] |= 1<<1;
    }

    /*GPIO32~34 bit2~4*/
    for (i=0; i<3; i++) {
        if (pin == (32+i) && (1<<(i+2))&GPIO_REG_PIN_MASK[1]) {
            reg_mask[1] |= 1<<(i+2);
        }
    }

    if (reg_mask[0]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg0_PD=0x%.8x\r\n", ept_gpio_cfg0->GPIO_PD.SET);
#endif
        temp = (ept_gpio_cfg0->GPIO_PD.SET&(~reg_mask[0]));
        temp |= (pullsel_temp[0]&reg_mask[0]);
        pullsel_temp[0] = temp;
        ept_gpio_cfg0->GPIO_PD.CLR = reg_mask[0];
        ept_gpio_cfg0->GPIO_PD.SET = pullsel_temp[0];
    }

    if (reg_mask[1]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg1_PD=0x%.8x\r\n", ept_gpio_cfg1->GPIO_PD.SET);
#endif
        temp = (ept_gpio_cfg1->GPIO_PD.SET&(~reg_mask[1]));
        temp |= (pullsel_temp[1]&reg_mask[1]);
        pullsel_temp[1] = temp;
        ept_gpio_cfg1->GPIO_PD.CLR = reg_mask[1];
        ept_gpio_cfg1->GPIO_PD.SET = pullsel_temp[1];
    }

#ifdef EPT_DEBUG_LOG
    printf("cfg0_PD: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PD: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PD: pullsel_temp[0]=0x%.8x\r\n", pullsel_temp[0]);
    printf("cfg1_PD: pullsel_temp[1]=0x%.8x\r\n", pullsel_temp[1]);
#endif
#endif
}

void gpio_pin_pupd_default(uint8_t pin)
{
    uint32_t i, temp;
    uint32_t reg_mask[GPIO_PUPD_REG_MAX_NUM];

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t pupd_temp[GPIO_PUPD_REG_MAX_NUM] = { GPIO_PUPD_ALL_VALUE };

    for (i=0;i<GPIO_PUPD_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO0 bit0*/
    if (pin == 0 && GPIO_REG_PIN_MASK[0] & (1<<0)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO1 bit1*/
    if (pin == 1 && GPIO_REG_PIN_MASK[0] & (1<<1)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO3 bit2*/
    if (pin == 3 && GPIO_REG_PIN_MASK[0] & (1<<3)) {
        reg_mask[0] |= 1<<2;
    }

    /*GPIO4 bit3*/
    if (pin == 4 && GPIO_REG_PIN_MASK[0] & (1<<4)) {
        reg_mask[0] |= 1<<3;
    }

    /*GPIO6~23 bit4~21*/
    for(i=4; i<22;i++) {
        if (pin == (2+i) && (1<<(i+2))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<i;
        }
    }

    /*GPIO35 bit0*/
    if (pin == 35 && GPIO_REG_PIN_MASK[1] & (1<<3)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO36 bit1*/
    if (pin == 36 && GPIO_REG_PIN_MASK[1] & (1<<4)) {
        reg_mask[1] |= 1<<1;
    }

    if (reg_mask[0]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg0_PUPD=0x%.8x\r\n", ept_gpio_cfg0->GPIO_PUPD.SET);
#endif
        temp = (ept_gpio_cfg0->GPIO_PUPD.SET&(~reg_mask[0]));
        temp |= (pupd_temp[0]&reg_mask[0]);
        pupd_temp[0] = temp;
        ept_gpio_cfg0->GPIO_PUPD.CLR = reg_mask[0];
        ept_gpio_cfg0->GPIO_PUPD.SET = pupd_temp[0];
    }

    if (reg_mask[1]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg1_PUPD=0x%.8x\r\n", ept_gpio_cfg1->GPIO_PUPD.SET);
#endif
        temp = (ept_gpio_cfg1->GPIO_PUPD.SET&(~reg_mask[1]));
        temp |= (pupd_temp[1]&reg_mask[1]);
        pupd_temp[1] = temp;
        ept_gpio_cfg1->GPIO_PUPD.CLR = reg_mask[1];
        ept_gpio_cfg1->GPIO_PUPD.SET = pupd_temp[1];
    }

#ifdef EPT_DEBUG_LOG
    printf("cfg0_PUPD: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg1_PUPD: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg0_PUPD: pullsel_temp[0]=0x%.8x\r\n", pupd_temp[0]);
    printf("cfg1_PUPD: pullsel_temp[1]=0x%.8x\r\n", pupd_temp[1]);
#endif
#endif
}

void gpio_pin_r0_r1_default(uint8_t pin)
{
    uint32_t i, temp;
    uint32_t reg_mask[GPIO_R0R1_REG_MAX_NUM];

#ifdef GPIO_PUPD_REG_MAX_NUM
    uint32_t r0_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R0_ALL_VALUE };
    uint32_t r1_temp[GPIO_R0R1_REG_MAX_NUM] = { GPIO_R1_ALL_VALUE };

    for (i=0;i<GPIO_R0R1_REG_MAX_NUM;i++) {
        reg_mask[i] = 0;
    }

    /*GPIO0 bit0*/
    if (pin == 0 && GPIO_REG_PIN_MASK[0] & (1<<0)) {
        reg_mask[0] |= 1<<0;
    }

    /*GPIO1 bit1*/
    if (pin == 1 && GPIO_REG_PIN_MASK[0] & (1<<1)) {
        reg_mask[0] |= 1<<1;
    }

    /*GPIO3 bit2*/
    if (pin == 3 && GPIO_REG_PIN_MASK[0] & (1<<3)) {
        reg_mask[0] |= 1<<2;
    }

    /*GPIO4 bit3*/
    if (pin == 4 && GPIO_REG_PIN_MASK[0] & (1<<4)) {
        reg_mask[0] |= 1<<3;
    }

    /*GPIO6~23 bit4~21*/
    for(i=4; i<22;i++) {
        if (pin == (2+i) && (1<<(i+2))&GPIO_REG_PIN_MASK[0]) {
            reg_mask[0] |= 1<<(i);
        }
    }

    /*GPIO35 bit0*/
    if (pin == 35 && GPIO_REG_PIN_MASK[1] & (1<<3)) {
        reg_mask[1] |= 1<<0;
    }

    /*GPIO36 bit1*/
    if (pin == 36 && GPIO_REG_PIN_MASK[1] & (1<<4)) {
        reg_mask[1] |= 1<<1;
    }

    if (reg_mask[0]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg0_R0=0x%.8x\r\n", ept_gpio_cfg0->GPIO_R0.SET);
        printf("cfg0_R1=0x%.8x\r\n", ept_gpio_cfg0->GPIO_R1.SET);
#endif
        temp = (ept_gpio_cfg0->GPIO_R0.SET&(~reg_mask[0]));
        temp |= (r0_temp[0]&reg_mask[0]);
        r0_temp[0] = temp;
        temp = (ept_gpio_cfg0->GPIO_R1.SET&(~reg_mask[0]));
        temp |= (r1_temp[0]&reg_mask[0]);
        r1_temp[0] = temp;
        ept_gpio_cfg0->GPIO_R0.CLR = reg_mask[0];
        ept_gpio_cfg0->GPIO_R1.CLR = reg_mask[0];
        ept_gpio_cfg0->GPIO_R0.SET = r0_temp[0];
        ept_gpio_cfg0->GPIO_R1.SET = r1_temp[0];
    }

    if (reg_mask[1]) {
#ifdef EPT_DEBUG_LOG
        printf("cfg1_R0=0x%.8x\r\n", ept_gpio_cfg1->GPIO_R0.SET);
        printf("cfg1_R1=0x%.8x\r\n", ept_gpio_cfg1->GPIO_R1.SET);
#endif
        temp = (ept_gpio_cfg1->GPIO_R0.SET&(~reg_mask[1]));
        temp |= (r0_temp[1]&reg_mask[1]);
        r0_temp[1] = temp;
        temp = (ept_gpio_cfg1->GPIO_R1.SET&(~reg_mask[1]));
        temp |= (r1_temp[1]&reg_mask[1]);
        r1_temp[1] = temp;
        ept_gpio_cfg1->GPIO_R0.CLR = reg_mask[1];
        ept_gpio_cfg1->GPIO_R1.CLR = reg_mask[1];
        ept_gpio_cfg1->GPIO_R0.SET = r0_temp[1];
        ept_gpio_cfg1->GPIO_R1.SET = r1_temp[1];
    }

#ifdef EPT_DEBUG_LOG
    printf("cfg0_R0: reg_mask[0]=0x%.8x\r\n", reg_mask[0]);
    printf("cfg0_R0: r0_temp[0]=0x%.8x\r\n", r0_temp[0]);
    printf("cfg0_R1: r1_temp[0]=0x%.8x\r\n", r1_temp[0]);
    printf("cfg1_R0: reg_mask[1]=0x%.8x\r\n", reg_mask[1]);
    printf("cfg1_R0: r0_temp[1]=0x%.8x\r\n", r0_temp[1]);
    printf("cfg1_R1: r1_temp[1]=0x%.8x\r\n", r1_temp[1]);
#endif
#endif
}

void gpio_pin_output_default(uint8_t pin)
{
    uint32_t i,j;
    uint32_t reg_mask[GPIO_OUTPUT_LEVEL_REG_MAX_NUM];
    uint32_t temp;

#ifdef GPIO_OUTPUT_LEVEL_REG_MAX_NUM
    uint32_t out_temp[GPIO_OUTPUT_LEVEL_REG_MAX_NUM] = { GPIO_OUTPUT_LEVEL_ALL_VALUE };

    i = pin / GPIO_OUTPUT_LEVEL_ONE_REG_CONTROL_NUM;
    j = pin % GPIO_OUTPUT_LEVEL_ONE_REG_CONTROL_NUM;
    reg_mask[i] = 0;
    if ((1<<(pin%32)) & GPIO_REG_PIN_MASK[pin/32]) {
        reg_mask[i] |= (1<<(GPIO_OUTPUT_LEVEL_ONE_CONTROL_BITS*j));
    }

    ept_gpio_base->GPIO_DOUT.CLR[i] = reg_mask[i];
    temp = ept_gpio_base->GPIO_DOUT.SET[i]&(~reg_mask[i]);
    temp |= (out_temp[i]&reg_mask[i]);
    ept_gpio_base->GPIO_DOUT.SET[i] = temp;

#ifdef EPT_DEBUG_LOG
    printf("GPIO_OUT[%d]: =0x%.8x, reg_mask[%d]=0x%.8x\r\n",i, temp,i,reg_mask[i]);
#endif
#endif
}

void bsp_ept_gpio_setting_pin_default(uint8_t pin)
{
#ifdef EPT_DEBUG_LOG
    printf("[%s]pin=%d\r\n", __func__, pin);
#endif

    gpio_pin_mode_default(pin);
    gpio_pin_dir_default(pin);
    gpio_pin_pu_default(pin);
    gpio_pin_pd_default(pin);
    gpio_pin_pupd_default(pin);
    gpio_pin_r0_r1_default(pin);
    gpio_pin_output_default(pin);
}
